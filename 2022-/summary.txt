
1. Integral Array [solved] (diff=1800, ad-hoc)
I'm actually quite amazed someone cannot solve this problem in contest, because I believe we've studied this technique
for at least 10 times in the 2020 training :).
Just use the property of partial sum n/1 + n/2 + ... + n/n = O(nlogn), manipulate the y value, and also the quotient.
https://codeforces.com/contest/1649/problem/D

2. Progressions Covering [solved] (diff=1900, greedy + any data structure)
The idea is too simple, just start from the right and use the range addition of arithmetic progression template.

3. Narrow Components [solved] (diff=2500, range tree, divide and conquer, union find)
The idea is exactly the same as https://codeforces.com/problemset/problem/811/E . I'm amazed someone can't solve it in contest.
https://codeforces.com/contest/1661/problem/E

4. Potion Brewing Class [solved] (diff=2100, ad-hoc?)
It is a very simple problem, but I got wrong answer many times because of the place to take mod :(.
https://codeforces.com/contest/1654/problem/D

5.  Lost Arithmetic Progression [solved] (diff=1900, ad-hoc)
Just manipulate the common difference of the sequence A. It must be a factor of the difference of C, and LCM(diff[A], diff[B]) = diff[C]
https://codeforces.com/contest/1673/problem/D

6 - 9 First rated div2 contest [A-D] [solved], https://codeforces.com/contest/1679

10. Traps [solved] (diff=1700, greedy)
https://codeforces.com/contest/1684/problem/D

11. 388535 [fail] (diff=2300, trie)
It is obvious that x = l ^ a[i] for some 1 <= i <= r - l + 1. Then, we just need to answer what's the minimum
(resp. maximum) of a[i] ^ x and check if it is equal to l (resp. r). https://codeforces.com/contest/1658/problem/D2

12. K-good [fail] (diff=1900, math)
Pattern finding? https://codeforces.com/contest/1656/problem/D

13. Tokitsukaze and Two Colorful Tapes [fail] (diff=1900, math + greedy)
The idea is to convert the permutation into the "graph". But the main obstacle is how to arange the numbers given the component size.
The technique is to put the larger numbers at the increasing point, and the smaller numbers at the decreasing points.


14. Staircases [fail] (diff=2100, ad-hoc?)
The key here is to realize we only need "maximal" staircases, which are stair cases that cannot be extended in either ends.
With this observation, the problem can be solved easily.  The reason I didn't solve it is mainly because I thought how to calculate 
the final answer using the simple dp way instead of this critical observation. The simple dp cannot be maintained 
within the correct time complexity. https://codeforces.com/contest/1598/problem/E


-- SWERC 2021 - 2022


15. Organizing SWERC [solved] (simulation)
https://codeforces.com/contest/1662/problem/A 

16. Bottle Arrangements [solved] (construction)
https://codeforces.com/contest/1662/problem/M

17. Boundary [solved] (math)
Just do some simple case work, time complexity O(T * sqrt(max(W, L))) https://codeforces.com/contest/1662/problem/H

18. Il Derby della Madonnina [solved] (range tree, dp)
dp[i] = max(dp[j] + 1 such that 0 <= j < i and |a[i] - a[j]| <= v * (t[i] - t[j])), 
which the condition is v * (t[j] - t[i]) <= a[i] - a[j] <= v * (t[i] - t[j]), v * t[j] + a[j] <= a[i] + v * t[i], and
v * t[j] - a[j] <= v * t[i] - a[i]. Thus we are asked the longest non-decreasing subsequence such that for (v * t[i] - a[i], v * t[i] + a[i])
https://codeforces.com/contest/1662/problem/L

19. Circular Maze [solved] (dfs)
The idea is to use the polar coordinate interpretation. We treat each 1-degree/1-radius region as a vertex, 
and treat the walls/circular walls as the edges we must delete.
Then, the question would be a very standard connectivity problem. https://codeforces.com/contest/1662/problem/O

20. Ice Cream Shop [solved] (sweep line)
For each hub, there's an interval that the people in the hub would buy ice-cream in the store if the store is in  such interval.
Find such interval for each hub using binary search, and use sweep line to do the task. https://codeforces.com/contest/1662/problem/I

21. Antennas [solved] (BFS, range tree)
Problems similar to this are CF605D and CF198E. Seems like in data structure at least, my problem solving ability is not too far away
from state of art :)? The idea is there are only a limited number of states but the number of edges in the graph is too many.
We need to find nxt in BFS efficiently.
There are two possibilities: 1) nxt > curr 2) nxt < curr. Here > and < means compare the id of the state.
We only explain case 1, because case 2 is dual.
For case 1, the idea is if i is connected to j (i < j), then i + p[i] >= j and j - p[j] <= i.
Therefore, we maintain a range min tree such that each node stores i - p[i].
If a state is visited, we simply set its value to be INF. hen, at each state, we just find the minimum value also the position of 
the minimum value in the range [state id, min(N, state id + p[state id])]. Let's call it (val, pos). Then, if val < state, we can simply 
set dist[pos] = dist[state id] + 1 and also mark the state as visited. For case 2, just use a range max tree instead of range min tree.
One thing to note is when we mark a node as visited, we must update the position in both trees to be INF/-INF.
https://codeforces.com/contest/1662/problem/F


22. Evolution of Weasels [fail] (constriction)
The critical observation is every B can be moved to arbitrary places in the string, but not A and C.
The relative order of A and C cannot be changed. Thus, the idea is to firstly move all Bs to the left,
and reduce 'AA' and 'CC'. https://codeforces.com/contest/1662/problem/D


23. Drone Photo [fail] (ad-hoc)
This problem is very technical. N=1500 makes me feel it's impossible to be data structure optimization,
and it proves to be a correct guess. The idea is to calculate contribution, but the approach to it
is quite difficult to come up with. The idea is for each number we calculate how many numbers are less than it in the same row/same col.
Let's represent these two quatities as row[i][j] and col[i][j].
Then, the answer is sum(row[i][j] * (N - 1 - col[i][j]) + col[i][j] * (N - 1 - row[i][j]), i=1..N, j=1..N) / 2.
Why this is correct can be verified by drawing a few cases. https://codeforces.com/contest/1662/problem/N


24. Unique Occurrences [solved] (diff=2300,range tree, dynamic connectivity)
We consider the contribution of each edge (u, v, c). It is equal to the size of the component contains u times the size of the
component contains v based on the forest with all the edges with color c removed. This changes the problem to a dynamic
connectivity problem, add some edges, remove some edges, query the component size.
Which can be solved with the range tree on query technique taught by Professor Ray Li. https://codeforces.com/contest/1681/problem/F

25. Yet Another Minimization Problem [solved] (diff=1800, dp)
We need to realize the optimized term is equal to (a[1] + a[2] + ... + a[n])^2 + (b[1] + b[2] + ... + b[n])^2 + (n-2) * (a[1]^2 + ... + a[n]^2 + b[1]^2 + ... + b[n]^2).
Only the first two terms are relevant to the order of the numbers. This transforms the problem to a simple dp. 
https://codeforces.com/contest/1637/problem/D

26. Best Pair [solved] (diff=2100, ad-hoc)
The observation is there are at most sqrt(N) many frequencies, we can group the numbers according to frequency, 
and then just brute force. https://codeforces.com/contest/1637/problem/E

27. Weight the Tree [solved] (diff=2000, ad-hoc, dp)
The idea is to realize unless N=2, there cannot be two adjacent nodes that are all good.
Then, the problem reduces to the following: give a tree, no two nodes that are adjacent can be selected at the
same time. If a node is selected, the weight is deg[v], otherwise, the weight is 1.
Find a set of valid selection such that the number of selected node is maximum, and among them choose the selection
that has the least sum of weight. It's a classic dp. https://codeforces.com/problemset/problem/1646/D

28. Take a Guess [solved] (diff=1800, ad-hoc)
The idea is we can solve x[1], x[2], x[3] based on the query result of x[1] & x[2], x[1] | x[2], x[1] & x[3], x[1] | x[3], x[3] & x[2], x[3] | x[2]. 
After that, we can know x[4] to x[n] based on
queries like x[1] | x[i], x[1] & x[i]. https://codeforces.com/contest/1556/problem/D

29. Not Adding [solved] (diff=1900, ad-hoc, number theory)
The idea is to check if each of 1 to 1e6 can be the gcd of some subset of the numbers in the array. 
To do this, we can calculate the gcd of all numbers that are a multiple of i for each i=1..1e6.
If the gcd is equal to i, then i can be formed. https://codeforces.com/contest/1627/problem/D

30. Vlad and Unfinished Business [solved] (diff=1800, ad-hoc)
https://codeforces.com/problemset/problem/1675/F

31. Replace the Numbers [solved] (diff=1900, union find)
For each number we create a tuple (x, t[x]) which means number x with the t[x]-th version. 
The problem can be reduced to a standard union-find problem.
https://codeforces.com/contest/1620/problem/E

32. Exact Change [solved] (diff=2000, brute force, ad-hoc)
The idea is we do not need more than 3 coins of weight 1, more than 3 coins of weight 2, and the number of coins we need for type 3 
is related to the maximum weighted coin. We can brute force the number of weight 1 coin, the number of weight 2 coin. 
https://codeforces.com/contest/1620/problem/D

33. Subsequences Galore [fail] (diff=2400, bitmask dp)
The intuition is quite simple. For each mask, we want to calculate the answer. 
However, there are duplicates, we want to know what's the duplication for each of the mask. For "mask",
the duplicate is equal to (min[mask]['a'] + 1) * (min[mask]['b'] + 1) * .... 
The remaining problem is how to calculate the subset sum efficiently. We can use the SOS sum.
https://codeforces.com/contest/1620/problem/G

34 - 38 codeforces round 795 div2 A - E :(
https://codeforces.com/contest/1691

39. Too Many Impostors (easy version) [solved] (diff=1800, ad-hoc, construction)
The easy version is truly easy. We can just query (i, i + 1, i + 2) for all i = 1..N-2. 
Then, we must realize there exists some i and i+1 such that
(i, i+1, i+2) returns differently from (i+1,i+2,i+3). 
This would ensure we know at a zero and an one. Then, we can get everything with this info.
https://codeforces.com/contest/1617/problem/D1

40. Too Many Impostors (hard version) [solved] (diff=2400, ad-hoc, construction)
The hard version is not truly hard. There are 3 observations: 
1) if we query (1, 2, 3), (4, 5, 6), ..., we can get at least a zero and at least a one.
2) after we retrieve the zero and one, we can determine the values of the 6 numbers using an additional 6 queries, 
how it can be done is related to part D1.
3) then, we only have 2n/3 queries remaining, for each of the (1, 2, 3), ... queries we have done in phase 1, 
if the result is 0, we can query twice (1, 2, pos_1), (2, 3, pos_1)
for example, and determine all numbers, similar for the result of 1. https://codeforces.com/contest/1617/problem/D2

41. GCD and MST [solved] (diff=2000, union find)
The idea is quite standard, since gcd <= min, we just need to manipulate the min element of each interval. 
And each interval is centered at a[i], and the left side and right side contain numbers that are multiple of a[i]. 
https://codeforces.com/contest/1513/problem/D

42. Cut [solved] (diff=2100, binary-lifting)
The observation is we can always pick the intervals greedily. For each index i, if we want to extent the subrange to the right, 
the first place to stop is the place to stop for i + 1 or the index j such that a[j] contains the same prime as a[i]. 
With this observation, we can construct a functional graph, each node has a link to the right. 
We want to know what's the minimum number of steps to jump from l to anywhere that's on the right of r. 
This can be done easily with binary-lifting (actually the idea from https://codeforces.com/contest/1175/problem/E). 
https://codeforces.com/contest/1516/problem/D

43. Interacdive Problem [solved] (diff=2000, ad-hoc)
The problem is similar to the trick of problem I in https://codeforces.com/gym/100307/attachments. 
For that problem I, I had no idea, but this time I know how this problem can be solved. 
The idea is to query c that can have the highest information gain (i.e. regardless of what's the return of the query we can remove the most number). 
For that problem I, I remembered Ali used binary search to search the binarys search bound. 
But given the constraints of this problem, we can just use brute force to search that bound.
https://codeforces.com/contest/1624/problem/F

44. MinOr Tree [solved] (diff=1900, union find, greedy)
The idea is we check the bits from high to low, and see if we can ignore a bit but still form a valid spanning tree, 
if not, we must contain that bit. https://codeforces.com/contest/1624/problem/G

45. notepad.exe [fail] (diff=2200, ad-hoc)
The problem is quite amazing. It's very natrual to come up with a solution that requires n * log(n * 2000) many queries, just by iterating through
all possible heights and query the minimum W that can produce this height. However, that's wrong answer, the number of queries is too much.
The idea is we can spend log(n * 2000) many queries to get the total length of A = l_i + (n - 1). Next, we need to apply a critical observation, which
is for a specific height, the minimum area possible is A - h + 1. Note that, the area must be within [A - h + 1, A], otherwise, it's either invalid
or unoptimal. Another observation is the area for a specific height h must be divisible by h, and this solves the problem. We only need to do 1 query
per height from 1 to n. https://codeforces.com/contest/1672/problem/E

46. Paired Payment [solved] (diff=2200, shortest path)
We should notice that the edge weight is no greater than 50, we can make good use of that. Define dist[v][pre] as the minimum distance
from vertex 1 to vertex v while the previous edge connect to v has weight pre. This can easily cover all states. The only thing to be careful
is when pre=0, we mean the node v is "reachable" from 1 by going the "2-step" moves. https://codeforces.com/problemset/problem/1486/E

47 - 51 Educational Codeforces Round 125  A - E
https://codeforces.com/contest/1657

52. Two Houses [solved] (diff=2200, ad-hoc)
The idea is once we run the top-sort algorithm, there are only deg != 0 vertices. If there's no such vertex, the answer is "! 0 0".
Otherwise, there's always a solution. We check the pairs from the largest difference of in-degree to the minimum difference of in-degree,
once the judge returns yes, we just print the pair. https://codeforces.com/contest/1498/problem/E

53 - 57 Educational Codeforces Round 110 A - E
https://codeforces.com/contest/1535

58. Equilibrium [solved] (diff=2200, range tree, ad-hoc)
We can create the cumulative sum array for b[i] - a[i]. Then, the answer is simply the maximum element in the range [l, r] - prefix[l-1].
The -1 case happens when the cumulative sum of range [l, r] is not 0 or there exists a negative element of the cumulative sum created by the subarray
[l, r]. https://codeforces.com/contest/1556/problem/E

59. Power Board [solved] (diff=2200, ad-hoc)
This problem is a pure "problem solving problem". We should observe if a number has prime factorization mul(p1^r1,p2^r2,p3^r3,...pn^rn), it can only
create duplicates with mul(p1^(r1 * g),p2^(r2 * g),p3^(r3 * g),...pn^(rn * g)) for some g. Not difficult to observe g < 20.
Thus, we can calculate the answer based on groups, each group is some number with prime factorazation such that the gcd(r1, r2, ..., rn) = 1.
How to calculate the answer for each group is relatively simple. https://codeforces.com/contest/1646/problem/E

60. Equidistant Vertices [solved] (diff=2200, ad-hoc, dp)
When K=2, the answer is just C(N, 2). Otherwise, the points must be distributed with respect to a "center" and has equal distance to the "center".
We can manipulate the center and also the distance. However, somewhere we can get wrong answer is just count how many points are distance d away from
the center c while ignoring that some of the points can not be selected together. Suppose the center is C, then we need to group the points into 
several groups with respect to the child of C. Each child we can only select a single point. This reduces the problem to a knapsack dp problem.
Overall time complexity O(K*N^2). https://codeforces.com/contest/1551/problem/F

61. Cars [solved] (diff=2200, bipartite coloring, top-sort)
If we have a constraint, it is easy to see that the two cars must move in the opposite direction. This observation tells us we can construct a 
bipartite graph, and do black/white coloring. If the color is black, we say the car is moving left, otherwise, the car moves right. Now once 
we fix the directions, we can calculate the relative position of the cars using top-sort. https://codeforces.com/problemset/problem/1635/E

62. Train Maintenance [solved] (diff=2200, sqrt decomposition)
If x + y is large, we can simply brute force and update all the related intervals. If x + y is short, we know that the train is under maintainance
if and only if the date % (x + y) is within the maintainance range. Note that if (x + y) is small, the range is small as well. Hence, our solution
is set the x + y limit to be sqrt(M), and deal with these two cases seperately. https://codeforces.com/contest/1580/problem/C

63. Non-Decreasing Dilemma [solved] (diff=2200, range tree, divide and conquer)
I've solved these kind of problem +inf many times, no comment. https://codeforces.com/contest/1567/problem/E

64. Ezzat and Grid [fail] (diff=2200, range tree, dp)
The problem is quite amazing, minimum remove = N - maximum keep. Then, the problem is reduced to a LIS type dp problem, which can be optimized
with range tree. https://codeforces.com/problemset/problem/1557/D

65. Anonymity Is Important [solved] (diff=2200, ad-hoc, range tree)
A position is not sick, if and only if there's a 0 covered that position. If a position is sick if and only if the position is not covered
by a 0 and there exists a "sick" segment that go through the position and has all but one index marked as "not sick". We can use a range tree
to maintain what's the minimum right point of a sick segment for each position. https://codeforces.com/problemset/problem/1641/C

66. Omkar and Forest [solved] (diff=2300, ad-hoc)
An observation is if we fix the positions that contain 0, and let the other spots contain positive numbers only, there's exactly 1 way of filling
the other spots. Hence, the answer is power(2, total number of '#'). Note that there is a special case. If the size is greater than 1 by 1 and
there does not exist a 0 in the grid, we have to subtract 1 from the answer, since there can't be a configuration that contains no 0.
https://codeforces.com/problemset/problem/1536/E

67. Moment of Bloom [fail] (diff=2200, ad-hoc, construction)
The problem is again the "odd-even" observation. We print no if and only if there exists some vertex appear odd times in the queries.
Also, normally for a graph construction problem, we need to transform it to a tree construction problem.
https://codeforces.com/problemset/problem/1586/E

68. Banquet Preparations 2 [solved] (diff=2200, greedy)
This problem can be reduced to the standard greedy problem: given a set of intervals, what's the minimum number of points you need to put
such that each interval contains at least 1 point. https://codeforces.com/contest/1607/problem/H

69. Paint the Middle [solved] (diff=2200, greedy, line sweep)
https://codeforces.com/contest/1631/problem/E

70. Changing Brackets [solved] (diff=2200, ad-hoc)
I'm actually quite excited that I can solve this ad-hoc problem, even if it's not hard. The idea is instead of thinking how many '[' or ']' we
need to change to round ones, we think initially we have every square brackets changed to round and how many we can put back. We can make the following
important observation: for a given interval, suppose there are x many square brackets has indices in odd position, and y in even position,
the answer is max(x, y) - min(x, y). Which basically means we can pair up brackets at odd positions with even positions, and it's not hard to show 
that if the remaining brackets are round, we can always construct a valid brackets subarray. https://codeforces.com/contest/1593/problem/G

71. Fair Share [solved] (diff=2400, euler path, ad-hoc)
This problem is very excited, seems like my linear programming/integer programming level increased after taking COMP9334 :).
The idea is we model the following system of equations:
define f(v, j) \in {1,-1} as if the number v occurs in the ith array has appear in the L set (1) or R set (-1).
Then, for each array j we have
sum(f(v, j), v \in array[j]) = 0
Similarly, for each number v, we have 
sum(f(v, i), v \in array[i] for some i) = 0
Note that this is a typical type of equation that can be modeled as an euler circuit. 
The nodes in the graph are all distinct numbers and the array ids.
For each number v in the array i, we add an undirected edge <i, v>. The answer to the question is yes if and only if there are many disjointed 
euler cycles. And to print the answer, we just need to direct the edges of those circuits, let's say if the traversal is from array index --> number,
we put the number to the R set, otherwise, L set. https://codeforces.com/contest/1634/problem/E

72. Arithmetic Operations [fail] (diff=2300, sqrt decomposition)
An important property I forgot: for arithmetic progression, we can subtract i * d from a[i] and check the mode of the sequence to see the 
maximum number of elements we can save. Given this property, when d is small, we can just use this brute force way of checking.
If d is large, note that for each number i, we can only save numbers which index in range [i - 1e5 / d, i + 1e5 / d]. This gives us the full solution.
https://codeforces.com/contest/1654/problem/E

73. Pattern Matching [solved] (diff=2300, top-sort)
The idea is quite simple. For a string, it can only match at most 2^K many patterns. It is if a position j of the string is x, the jth position of the 
pattern must be either x or '_'. With this observation, the constraint simply says a pattern should be in front of all the other patterns the string 
i matches. The answer is yes if and only if there's a partial order that can model all these constraints. It's a typical top-sort problem.
https://codeforces.com/contest/1476/problem/E

74. Hemose in ICPC ? [solved] (diff=2300, ad-hoc)
The gcd is definitely the maximum edge in the graph. Hence, we can do queries according to dfs order. The query type is query all the points 
that has dfs order no greater than x. Binary search the smallest x such that the query returns the same value as we put in all the points.
Answer would be x and the parent of x. https://codeforces.com/contest/1592/problem/D

75. Tree Array [fail] (diff=2300, dp)
This is hard. The problem can be eventually transformed into the following: given two numbers x and y, we can reduce 1 from x/y with equal probability,
and there's also a probability of not doing anything at each step. What's the probability of x be reduced to 0 before y. This problem can be solved with
dp. And the probability of not doing anything doesn't matter. Now, let's think how this problem relates to the reduced problem. For a pair (a, b),
before the lca is selected, any sequence of moves won't affect the outcome. Hence, contribution of a pair (a, b) a > b can be interpreted as the 
reduced problem given that x = height[a] - height[lca(a, b)], y = height[b] - height[lca(a, b)]. We should repeat the problem for every pair (a, b) 
for all root i = 1..N, sum up, and done. https://codeforces.com/contest/1540/problem/B

76. Two chandeliers [solved] (diff=2200, binary search, chinese remainder theorem)
Instead of counting how many days a[i] != b[i], we can binary search on the number of days and subtract the number of days a[i] = b[i].
Since each array is distinct, for v \in a, and v \in b, suppose v = a[x] and v = b[y]. Then, we want the minimum ans such that 
ans = x mod N and ans = y mod M. This equation can be solved by chinese remainder theorem, we just fill in the template and done. The template 
I found was copied from Edward's submission. https://codeforces.com/contest/1501/problem/D

77. Sereja and Squares [solved] (diff=2300, sqrt decomposition)
We partition the x coordinates into heavy-light. For the x-coordinate that has less than sqrt(N) many points, we just manipulate the points with 
brute force, for the x-coordinate that has more than sqrt(N) many points, we just manipulate pairs of heavy x-coordinates.
https://codeforces.com/contest/425/problem/D

78.  Guess The String [solved] (ad-hoc, binary search)
https://codeforces.com/contest/1697/problem/D

79. Enchanted Artifact [fail] (diff=2300, ad-hoc, greedy)
The idea is actually the simpliest one. Firstly try to get the length of the string, and how many 'a's and 'b's. Next, generate a string,
fix each position to the opposite, and see if the edit distance increased or not, if it increased, it means we shouldn't flip, otherwise, flip.
https://codeforces.com/contest/1282/problem/D

80. Good Graph [solved] (diff=2700, HLD)
There are two important observations: 
    (1) the odd cycles can only intersect at vertices but not edges
    (2) if an edge appears in an odd cycle, if the other odd cycle contains that edge, the second odd cycle is invalid
With these observations, we can use HLD to solve the problem. https://codeforces.com/contest/1555/problem/F

81. Make The Fence Great Again [solved] (diff=1800, dp)
The only observation is the maximum increase for each index is very limited. https://codeforces.com/contest/1221/problem/D

82. Easy Problem [solved] (diff=1800, dp)
We are basically modeling a finite state automa. The states are _, h, ha, har. We simply define dp as the minimum cost at the ith character 
to maintain each of those states. https://codeforces.com/contest/1096/problem/D



