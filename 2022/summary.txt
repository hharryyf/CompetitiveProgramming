
1. Integral Array [solved] (diff=1800, ad-hoc)
I'm actually quite amazed someone cannot solve this problem in contest, because I believe we've studied this technique
for at least 10 times in the 2020 training :).
Just use the property of partial sum n/1 + n/2 + ... + n/n = O(nlogn), manipulate the y value, and also the quotient.
https://codeforces.com/contest/1649/problem/D

2. Progressions Covering [solved] (diff=1900, greedy + any data structure)
The idea is too simple, just start from the right and use the range addition of arithmetic progression template.

3. Narrow Components [solved] (diff=2500, range tree, divide and conquer, union find)
The idea is exactly the same as https://codeforces.com/problemset/problem/811/E . I'm amazed someone can't solve it in contest.
https://codeforces.com/contest/1661/problem/E

4. Potion Brewing Class [solved] (diff=2100, ad-hoc?)
It is a very simple problem, but I got wrong answer many times because of the place to take mod :(.
https://codeforces.com/contest/1654/problem/D

5.  Lost Arithmetic Progression [solved] (diff=1900, ad-hoc)
Just manipulate the common difference of the sequence A. It must be a factor of the difference of C, and LCM(diff[A], diff[B]) = diff[C]
https://codeforces.com/contest/1673/problem/D

6 - 9 First rated div2 contest [A-D] [solved], https://codeforces.com/contest/1679

10. Traps [solved] (diff=1700, greedy)
https://codeforces.com/contest/1684/problem/D

11. 388535 [fail] (diff=2300, trie)
It is obvious that x = l ^ a[i] for some 1 <= i <= r - l + 1. Then, we just need to answer what's the minimum
(resp. maximum) of a[i] ^ x and check if it is equal to l (resp. r). https://codeforces.com/contest/1658/problem/D2

12. K-good [fail] (diff=1900, math)
Pattern finding? https://codeforces.com/contest/1656/problem/D

13. Tokitsukaze and Two Colorful Tapes [fail] (diff=1900, math + greedy)
The idea is to convert the permutation into the "graph". But the main obstacle is how to arange the numbers given the component size.
The technique is to put the larger numbers at the increasing point, and the smaller numbers at the decreasing points.


14. Staircases [fail] (diff=2100, ad-hoc?)
The key here is to realize we only need "maximal" staircases, which are stair cases that cannot be extended in either ends.
With this observation, the problem can be solved easily.  The reason I didn't solve it is mainly because I thought how to calculate 
the final answer using the simple dp way instead of this critical observation. The simple dp cannot be maintained 
within the correct time complexity. https://codeforces.com/contest/1598/problem/E


-- SWERC 2021 - 2022


15. Organizing SWERC [solved] (simulation)
https://codeforces.com/contest/1662/problem/A 

16. Bottle Arrangements [solved] (construction)
https://codeforces.com/contest/1662/problem/M

17. Boundary [solved] (math)
Just do some simple case work, time complexity O(T * sqrt(max(W, L))) https://codeforces.com/contest/1662/problem/H

18. Il Derby della Madonnina [solved] (range tree, dp)
dp[i] = max(dp[j] + 1 such that 0 <= j < i and |a[i] - a[j]| <= v * (t[i] - t[j])), 
which the condition is v * (t[j] - t[i]) <= a[i] - a[j] <= v * (t[i] - t[j]), v * t[j] + a[j] <= a[i] + v * t[i], and
v * t[j] - a[j] <= v * t[i] - a[i]. Thus we are asked the longest non-decreasing subsequence such that for (v * t[i] - a[i], v * t[i] + a[i])
https://codeforces.com/contest/1662/problem/L

19. Circular Maze [solved] (dfs)
The idea is to use the polar coordinate interpretation. We treat each 1-degree/1-radius region as a vertex, 
and treat the walls/circular walls as the edges we must delete.
Then, the question would be a very standard connectivity problem. https://codeforces.com/contest/1662/problem/O

20. Ice Cream Shop [solved] (sweep line)
For each hub, there's an interval that the people in the hub would buy ice-cream in the store if the store is in  such interval.
Find such interval for each hub using binary search, and use sweep line to do the task. https://codeforces.com/contest/1662/problem/I

21. Antennas [solved] (BFS, range tree)
Problems similar to this are CF605D and CF198E. Seems like in data structure at least, my problem solving ability is not too far away
from state of art :)? The idea is there are only a limited number of states but the number of edges in the graph is too many.
We need to find nxt in BFS efficiently.
There are two possibilities: 1) nxt > curr 2) nxt < curr. Here > and < means compare the id of the state.
We only explain case 1, because case 2 is dual.
For case 1, the idea is if i is connected to j (i < j), then i + p[i] >= j and j - p[j] <= i.
Therefore, we maintain a range min tree such that each node stores i - p[i].
If a state is visited, we simply set its value to be INF. hen, at each state, we just find the minimum value also the position of 
the minimum value in the range [state id, min(N, state id + p[state id])]. Let's call it (val, pos). Then, if val < state, we can simply 
set dist[pos] = dist[state id] + 1 and also mark the state as visited. For case 2, just use a range max tree instead of range min tree.
One thing to note is when we mark a node as visited, we must update the position in both trees to be INF/-INF.
https://codeforces.com/contest/1662/problem/F


22. Evolution of Weasels [fail] (constriction)
The critical observation is every B can be moved to arbitrary places in the string, but not A and C.
The relative order of A and C cannot be changed. Thus, the idea is to firstly move all Bs to the left,
and reduce 'AA' and 'CC'. https://codeforces.com/contest/1662/problem/D


23. Drone Photo [fail] (ad-hoc)
This problem is very technical. N=1500 makes me feel it's impossible to be data structure optimization,
and it proves to be a correct guess. The idea is to calculate contribution, but the approach to it
is quite difficult to come up with. The idea is for each number we calculate how many numbers are less than it in the same row/same col.
Let's represent these two quatities as row[i][j] and col[i][j].
Then, the answer is sum(row[i][j] * (N - 1 - col[i][j]) + col[i][j] * (N - 1 - row[i][j]), i=1..N, j=1..N) / 2.
Why this is correct can be verified by drawing a few cases. https://codeforces.com/contest/1662/problem/N


24. Unique Occurrences [solved] (diff=2300,range tree, dynamic connectivity)
We consider the contribution of each edge (u, v, c). It is equal to the size of the component contains u times the size of the
component contains v based on the forest with all the edges with color c removed. This changes the problem to a dynamic
connectivity problem, add some edges, remove some edges, query the component size.
Which can be solved with the range tree on query technique taught by Professor Ray Li. https://codeforces.com/contest/1681/problem/F

25. Yet Another Minimization Problem [solved] (diff=1800, dp)
We need to realize the optimized term is equal to (a[1] + a[2] + ... + a[n])^2 + (b[1] + b[2] + ... + b[n])^2 + (n-2) * (a[1]^2 + ... + a[n]^2 + b[1]^2 + ... + b[n]^2).
Only the first two terms are relevant to the order of the numbers. This transforms the problem to a simple dp. 
https://codeforces.com/contest/1637/problem/D

26. Best Pair [solved] (diff=2100, ad-hoc)
The observation is there are at most sqrt(N) many frequencies, we can group the numbers according to frequency, 
and then just brute force. https://codeforces.com/contest/1637/problem/E

27. Weight the Tree [solved] (diff=2000, ad-hoc, dp)
The idea is to realize unless N=2, there cannot be two adjacent nodes that are all good.
Then, the problem reduces to the following: give a tree, no two nodes that are adjacent can be selected at the
same time. If a node is selected, the weight is deg[v], otherwise, the weight is 1.
Find a set of valid selection such that the number of selected node is maximum, and among them choose the selection
that has the least sum of weight. It's a classic dp. https://codeforces.com/problemset/problem/1646/D

28. Take a Guess [solved] (diff=1800, ad-hoc)
The idea is we can solve x[1], x[2], x[3] based on the query result of x[1] & x[2], x[1] | x[2], x[1] & x[3], x[1] | x[3], x[3] & x[2], x[3] | x[2]. 
After that, we can know x[4] to x[n] based on
queries like x[1] | x[i], x[1] & x[i]. https://codeforces.com/contest/1556/problem/D

29. Not Adding [solved] (diff=1900, ad-hoc, number theory)
The idea is to check if each of 1 to 1e6 can be the gcd of some subset of the numbers in the array. 
To do this, we can calculate the gcd of all numbers that are a multiple of i for each i=1..1e6.
If the gcd is equal to i, then i can be formed. https://codeforces.com/contest/1627/problem/D

30. Vlad and Unfinished Business [solved] (diff=1800, ad-hoc)
https://codeforces.com/problemset/problem/1675/F

31. Replace the Numbers [solved] (diff=1900, union find)
For each number we create a tuple (x, t[x]) which means number x with the t[x]-th version. 
The problem can be reduced to a standard union-find problem.
https://codeforces.com/contest/1620/problem/E

32. Exact Change [solved] (diff=2000, brute force, ad-hoc)
The idea is we do not need more than 3 coins of weight 1, more than 3 coins of weight 2, and the number of coins we need for type 3 
is related to the maximum weighted coin. We can brute force the number of weight 1 coin, the number of weight 2 coin. 
https://codeforces.com/contest/1620/problem/D

33. Subsequences Galore [fail] (diff=2400, bitmask dp)
The intuition is quite simple. For each mask, we want to calculate the answer. 
However, there are duplicates, we want to know what's the duplication for each of the mask. For "mask",
the duplicate is equal to (min[mask]['a'] + 1) * (min[mask]['b'] + 1) * .... 
The remaining problem is how to calculate the subset sum efficiently. We can use the SOS sum.
https://codeforces.com/contest/1620/problem/G

34 - 38 codeforces round 795 div2 A - E :(
https://codeforces.com/contest/1691

39. Too Many Impostors (easy version) [solved] (diff=1800, ad-hoc, construction)
The easy version is truly easy. We can just query (i, i + 1, i + 2) for all i = 1..N-2. 
Then, we must realize there exists some i and i+1 such that
(i, i+1, i+2) returns differently from (i+1,i+2,i+3). 
This would ensure we know at a zero and an one. Then, we can get everything with this info.
https://codeforces.com/contest/1617/problem/D1

40. Too Many Impostors (hard version) [solved] (diff=2400, ad-hoc, construction)
The hard version is not truly hard. There are 3 observations: 
1) if we query (1, 2, 3), (4, 5, 6), ..., we can get at least a zero and at least a one.
2) after we retrieve the zero and one, we can determine the values of the 6 numbers using an additional 6 queries, 
how it can be done is related to part D1.
3) then, we only have 2n/3 queries remaining, for each of the (1, 2, 3), ... queries we have done in phase 1, 
if the result is 0, we can query twice (1, 2, pos_1), (2, 3, pos_1)
for example, and determine all numbers, similar for the result of 1. https://codeforces.com/contest/1617/problem/D2

41. GCD and MST [solved] (diff=2000, union find)
The idea is quite standard, since gcd <= min, we just need to manipulate the min element of each interval. 
And each interval is centered at a[i], and the left side and right side contain numbers that are multiple of a[i]. 
https://codeforces.com/contest/1513/problem/D

42. Cut [solved] (diff=2100, binary-lifting)
The observation is we can always pick the intervals greedily. For each index i, if we want to extent the subrange to the right, 
the first place to stop is the place to stop for i + 1 or the index j such that a[j] contains the same prime as a[i]. 
With this observation, we can construct a functional graph, each node has a link to the right. 
We want to know what's the minimum number of steps to jump from l to anywhere that's on the right of r. 
This can be done easily with binary-lifting (actually the idea from https://codeforces.com/contest/1175/problem/E). 
https://codeforces.com/contest/1516/problem/D

43. Interacdive Problem [solved] (diff=2000, ad-hoc)
The problem is similar to the trick of problem I in https://codeforces.com/gym/100307/attachments. 
For that problem I, I had no idea, but this time I know how this problem can be solved. 
The idea is to query c that can have the highest information gain (i.e. regardless of what's the return of the query we can remove the most number). 
For that problem I, I remembered Ali used binary search to search the binarys search bound. 
But given the constraints of this problem, we can just use brute force to search that bound.
https://codeforces.com/contest/1624/problem/F

44. MinOr Tree [solved] (diff=1900, union find, greedy)
The idea is we check the bits from high to low, and see if we can ignore a bit but still form a valid spanning tree, 
if not, we must contain that bit. https://codeforces.com/contest/1624/problem/G

45. notepad.exe [fail] (diff=2200, ad-hoc)
The problem is quite amazing. It's very natrual to come up with a solution that requires n * log(n * 2000) many queries, just by iterating through
all possible heights and query the minimum W that can produce this height. However, that's wrong answer, the number of queries is too much.
The idea is we can spend log(n * 2000) many queries to get the total length of A = l_i + (n - 1). Next, we need to apply a critical observation, which
is for a specific height, the minimum area possible is A - h + 1. Note that, the area must be within [A - h + 1, A], otherwise, it's either invalid
or unoptimal. Another observation is the area for a specific height h must be divisible by h, and this solves the problem. We only need to do 1 query
per height from 1 to n. https://codeforces.com/contest/1672/problem/E

46. Paired Payment [solved] (diff=2200, shortest path)
We should notice that the edge weight is no greater than 50, we can make good use of that. Define dist[v][pre] as the minimum distance
from vertex 1 to vertex v while the previous edge connect to v has weight pre. This can easily cover all states. The only thing to be careful
is when pre=0, we mean the node v is "reachable" from 1 by going the "2-step" moves. https://codeforces.com/problemset/problem/1486/E

47 - 51 Educational Codeforces Round 125  A - E
https://codeforces.com/contest/1657

52. Two Houses [solved] (diff=2200, ad-hoc)
The idea is once we run the top-sort algorithm, there are only deg != 0 vertices. If there's no such vertex, the answer is "! 0 0".
Otherwise, there's always a solution. We check the pairs from the largest difference of in-degree to the minimum difference of in-degree,
once the judge returns yes, we just print the pair. https://codeforces.com/contest/1498/problem/E

53 - 57 Educational Codeforces Round 110 A - E
https://codeforces.com/contest/1535

58. Equilibrium [solved] (diff=2200, range tree, ad-hoc)
We can create the cumulative sum array for b[i] - a[i]. Then, the answer is simply the maximum element in the range [l, r] - prefix[l-1].
The -1 case happens when the cumulative sum of range [l, r] is not 0 or there exists a negative element of the cumulative sum created by the subarray
[l, r]. https://codeforces.com/contest/1556/problem/E

59. Power Board [solved] (diff=2200, ad-hoc)
This problem is a pure "problem solving problem". We should observe if a number has prime factorization mul(p1^r1,p2^r2,p3^r3,...pn^rn), it can only
create duplicates with mul(p1^(r1 * g),p2^(r2 * g),p3^(r3 * g),...pn^(rn * g)) for some g. Not difficult to observe g < 20.
Thus, we can calculate the answer based on groups, each group is some number with prime factorazation such that the gcd(r1, r2, ..., rn) = 1.
How to calculate the answer for each group is relatively simple. https://codeforces.com/contest/1646/problem/E

60. Equidistant Vertices [solved] (diff=2200, ad-hoc, dp)
When K=2, the answer is just C(N, 2). Otherwise, the points must be distributed with respect to a "center" and has equal distance to the "center".
We can manipulate the center and also the distance. However, somewhere we can get wrong answer is just count how many points are distance d away from
the center c while ignoring that some of the points can not be selected together. Suppose the center is C, then we need to group the points into 
several groups with respect to the child of C. Each child we can only select a single point. This reduces the problem to a knapsack dp problem.
Overall time complexity O(K*N^2). https://codeforces.com/contest/1551/problem/F

61. Cars [solved] (diff=2200, bipartite coloring, top-sort)
If we have a constraint, it is easy to see that the two cars must move in the opposite direction. This observation tells us we can construct a 
bipartite graph, and do black/white coloring. If the color is black, we say the car is moving left, otherwise, the car moves right. Now once 
we fix the directions, we can calculate the relative position of the cars using top-sort. https://codeforces.com/problemset/problem/1635/E

62. Train Maintenance [solved] (diff=2200, sqrt decomposition)
If x + y is large, we can simply brute force and update all the related intervals. If x + y is short, we know that the train is under maintainance
if and only if the date % (x + y) is within the maintainance range. Note that if (x + y) is small, the range is small as well. Hence, our solution
is set the x + y limit to be sqrt(M), and deal with these two cases seperately. https://codeforces.com/contest/1580/problem/C

63. Non-Decreasing Dilemma [solved] (diff=2200, range tree, divide and conquer)
I've solved these kind of problem +inf many times, no comment. https://codeforces.com/contest/1567/problem/E

64. Ezzat and Grid [fail] (diff=2200, range tree, dp)
The problem is quite amazing, minimum remove = N - maximum keep. Then, the problem is reduced to a LIS type dp problem, which can be optimized
with range tree. https://codeforces.com/problemset/problem/1557/D

65. Anonymity Is Important [solved] (diff=2200, ad-hoc, range tree)
A position is not sick, if and only if there's a 0 covered that position. If a position is sick if and only if the position is not covered
by a 0 and there exists a "sick" segment that go through the position and has all but one index marked as "not sick". We can use a range tree
to maintain what's the minimum right point of a sick segment for each position. https://codeforces.com/problemset/problem/1641/C

66. Omkar and Forest [solved] (diff=2300, ad-hoc)
An observation is if we fix the positions that contain 0, and let the other spots contain positive numbers only, there's exactly 1 way of filling
the other spots. Hence, the answer is power(2, total number of '#'). Note that there is a special case. If the size is greater than 1 by 1 and
there does not exist a 0 in the grid, we have to subtract 1 from the answer, since there can't be a configuration that contains no 0.
https://codeforces.com/problemset/problem/1536/E

67. Moment of Bloom [fail] (diff=2200, ad-hoc, construction)
The problem is again the "odd-even" observation. We print no if and only if there exists some vertex appear odd times in the queries.
Also, normally for a graph construction problem, we need to transform it to a tree construction problem.
https://codeforces.com/problemset/problem/1586/E

68. Banquet Preparations 2 [solved] (diff=2200, greedy)
This problem can be reduced to the standard greedy problem: given a set of intervals, what's the minimum number of points you need to put
such that each interval contains at least 1 point. https://codeforces.com/contest/1607/problem/H

69. Paint the Middle [solved] (diff=2200, greedy, line sweep)
https://codeforces.com/contest/1631/problem/E

70. Changing Brackets [solved] (diff=2200, ad-hoc)
I'm actually quite excited that I can solve this ad-hoc problem, even if it's not hard. The idea is instead of thinking how many '[' or ']' we
need to change to round ones, we think initially we have every square brackets changed to round and how many we can put back. We can make the following
important observation: for a given interval, suppose there are x many square brackets has indices in odd position, and y in even position,
the answer is max(x, y) - min(x, y). Which basically means we can pair up brackets at odd positions with even positions, and it's not hard to show 
that if the remaining brackets are round, we can always construct a valid brackets subarray. https://codeforces.com/contest/1593/problem/G

71. Fair Share [solved] (diff=2400, euler path, ad-hoc)
This problem is very excited, seems like my linear programming/integer programming level increased after taking COMP9334 :).
The idea is we model the following system of equations:
define f(v, j) \in {1,-1} as if the number v occurs in the ith array has appear in the L set (1) or R set (-1).
Then, for each array j we have
sum(f(v, j), v \in array[j]) = 0
Similarly, for each number v, we have 
sum(f(v, i), v \in array[i] for some i) = 0
Note that this is a typical type of equation that can be modeled as an euler circuit. 
The nodes in the graph are all distinct numbers and the array ids.
For each number v in the array i, we add an undirected edge <i, v>. The answer to the question is yes if and only if there are many disjointed 
euler cycles. And to print the answer, we just need to direct the edges of those circuits, let's say if the traversal is from array index --> number,
we put the number to the R set, otherwise, L set. https://codeforces.com/contest/1634/problem/E

72. Arithmetic Operations [fail] (diff=2300, sqrt decomposition)
An important property I forgot: for arithmetic progression, we can subtract i * d from a[i] and check the mode of the sequence to see the 
maximum number of elements we can save. Given this property, when d is small, we can just use this brute force way of checking.
If d is large, note that for each number i, we can only save numbers which index in range [i - 1e5 / d, i + 1e5 / d]. This gives us the full solution.
https://codeforces.com/contest/1654/problem/E

73. Pattern Matching [solved] (diff=2300, top-sort)
The idea is quite simple. For a string, it can only match at most 2^K many patterns. It is if a position j of the string is x, the jth position of the 
pattern must be either x or '_'. With this observation, the constraint simply says a pattern should be in front of all the other patterns the string 
i matches. The answer is yes if and only if there's a partial order that can model all these constraints. It's a typical top-sort problem.
https://codeforces.com/contest/1476/problem/E

74. Hemose in ICPC ? [solved] (diff=2300, ad-hoc)
The gcd is definitely the maximum edge in the graph. Hence, we can do queries according to dfs order. The query type is query all the points 
that has dfs order no greater than x. Binary search the smallest x such that the query returns the same value as we put in all the points.
Answer would be x and the parent of x. https://codeforces.com/contest/1592/problem/D

75. Tree Array [fail] (diff=2300, dp)
This is hard. The problem can be eventually transformed into the following: given two numbers x and y, we can reduce 1 from x/y with equal probability,
and there's also a probability of not doing anything at each step. What's the probability of x be reduced to 0 before y. This problem can be solved with
dp. And the probability of not doing anything doesn't matter. Now, let's think how this problem relates to the reduced problem. For a pair (a, b),
before the lca is selected, any sequence of moves won't affect the outcome. Hence, contribution of a pair (a, b) a > b can be interpreted as the 
reduced problem given that x = height[a] - height[lca(a, b)], y = height[b] - height[lca(a, b)]. We should repeat the problem for every pair (a, b) 
for all root i = 1..N, sum up, and done. https://codeforces.com/contest/1540/problem/B

76. Two chandeliers [solved] (diff=2200, binary search, chinese remainder theorem)
Instead of counting how many days a[i] != b[i], we can binary search on the number of days and subtract the number of days a[i] = b[i].
Since each array is distinct, for v \in a, and v \in b, suppose v = a[x] and v = b[y]. Then, we want the minimum ans such that 
ans = x mod N and ans = y mod M. This equation can be solved by chinese remainder theorem, we just fill in the template and done. The template 
I found was copied from Edward's submission. https://codeforces.com/contest/1501/problem/D

77. Sereja and Squares [solved] (diff=2300, sqrt decomposition)
We partition the x coordinates into heavy-light. For the x-coordinate that has less than sqrt(N) many points, we just manipulate the points with 
brute force, for the x-coordinate that has more than sqrt(N) many points, we just manipulate pairs of heavy x-coordinates.
https://codeforces.com/contest/425/problem/D

78.  Guess The String [solved] (diff=1900, ad-hoc, binary search)
https://codeforces.com/contest/1697/problem/D

79. Enchanted Artifact [fail] (diff=2300, ad-hoc, greedy)
The idea is actually the simpliest one. Firstly try to get the length of the string, and how many 'a's and 'b's. Next, generate a string,
fix each position to the opposite, and see if the edit distance increased or not, if it increased, it means we shouldn't flip, otherwise, flip.
https://codeforces.com/contest/1282/problem/D

80. Good Graph [solved] (diff=2700, HLD)
There are two important observations: 
    (1) the odd cycles can only intersect at vertices but not edges
    (2) if an edge appears in an odd cycle, if the other odd cycle contains that edge, the second odd cycle is invalid
With these observations, we can use HLD to solve the problem. https://codeforces.com/contest/1555/problem/F

81. Make The Fence Great Again [solved] (diff=1800, dp)
The only observation is the maximum increase for each index is very limited. https://codeforces.com/contest/1221/problem/D

82. Easy Problem [solved] (diff=1800, dp)
We are basically modeling a finite state automa. The states are _, h, ha, har. We simply define dp as the minimum cost at the ith character 
to maintain each of those states. https://codeforces.com/contest/1096/problem/D

83. Journey [solved] (diff=1800, dp)
Just remember, we cannot use a 2-d long long array. Otherwise, we might get MLE. https://codeforces.com/contest/721/problem/C

84. A Twisty Movement [solved] (diff=1800, dp)
We can calculate the LIS between [l, r] for the reverse array. Then, the final answer is definitely some 1 -- the reverse [l, r], some 2.
Just manipulate [l, r] and done. https://codeforces.com/contest/933/problem/A

85. Gotta Go Fast [fail] (diff=2400, binary search, dp)
This problem is difficult because the state is cyclic. It's natrual to define dp[i][j] as the total minimum time to finish the game when we are 
at state i and have spent j in the current run. Then, dp[i][j] = min(dp[1][0], (dp[i+1][j+f[i]] + f[i]) * p[i] + (dp[i+1][j+s[i]] + s[i]) * (1 - p[i])).
However, we need future state to decide the current state. Now we can binary search on dp[1][0], and see if the derived dp[1][0] can be lower than 
this value, if yes, it means we can reduce the dp[1][0]. This technique actually appears in another problem https://codeforces.com/gym/103049/problem/G
https://codeforces.com/contest/867/problem/D

86. Double Happiness [fail] (diff=2200, number theory)
When t = 4k + 1 and is a prime, we can count it. https://codeforces.com/contest/113/problem/C

87. Palindromic Paths [solved] (diff=2400, ad-hoc)
We apply the following procedure: (1) fix all the value of the grid with coordinate (x + y) even. These values can be fixed by distance 2 queries.
(2) bipartite the grid with coordinate (x + y) odd. We can temporarily let one part to be 0 while the other be 1.
(3) there must exists a consecutive 4 cells such that its xor is 0. (4) query the 4 consecutive cells, fix the value for grid with coordinate (x + y) odd.
https://codeforces.com/contest/1205/problem/C

88 - 91 Educational Codeforces Round 124  A - D
https://codeforces.com/contest/1651

92. Unmerge [solved] (diff=1800, dp)
The observation is for a consecutive a[i], a[i+1], a[i+2], ...,a[j]. Unless there exists some k such that a[k] > a[i], these numbers must 
all be in one of the sequences. Hence, we can partition the array into chunks and reduce the problem to a standard knapsack dp.
https://codeforces.com/contest/1382/problem/D

93. Yet Another Subarray Problem [solved] (diff=1900, dp, ad-hoc)
https://codeforces.com/contest/1197/problem/D

94. Yet Another Problem On a Subsequence [solved] (diff=1900, dp)
Just define dp[i] as the number of sequences start at the ith element. https://codeforces.com/problemset/problem/1000/D

95. Catching Cheaters [solved] (diff=1800, dp)
This problem is just a modification to the standard LCS. https://codeforces.com/problemset/problem/1446/B

96 - 99 Codeforces Round #802 (Div. 2) A - D https://codeforces.com/contest/1700

100. Nauuo and Circle [solved] (diff=1900, tree dp)
https://codeforces.com/contest/1173/problem/D

101. Max Median [solved] (diff=2100, binary search)
The idea is exactly the same as an IOI problem. We binary search on the final answer. See if the Median is greater than v. 
To validate v, we set all numbers less than v to -1 and greater than v to be 1, we basically need to answer the question if we can 
find a subarray of length at least K such that it's sum is greater than 0. This is a simple two-pointer problem and can be solved within O(N) time.
Combine with the binary search, we basically find an O(NlogN) solution. https://codeforces.com/contest/1486/problem/D

102. Minimax Problem [solved] (diff=2000, binary search, bitmask)
Same as the previous problem, if we treat every number greater than or equal a threshold as 1, and a number less than the threshold as 0
we need to just find two masks such that its or value is the full mask. https://codeforces.com/contest/1288/problem/D

103. Armchairs [fail] (diff=1800, dp)
This problem is extremely sad. I almost forgot the LCS type dp transition function. The observation is if there are K '0' and K '1', we should 
match them from left to right. Hence we can just define dp[i][j] as the minimum cost to match the first i '0' with the first j '1'.
https://codeforces.com/contest/1525/problem/D

104. Assimilation IV [solved] (diff=2100, combinatorics)
We can calculate the probability each point is controlled independently and sum them up. To calculate the probability a point is controlled,
we basically need to answer the following question. Given a permutation of numbers, each number from 1 to N + 1, how many permutation 
has the property that a[i] > i for each i from 1 to N. This is a classic combinatorics problem, just use sweeping.
https://codeforces.com/contest/1525/problem/E

105.  The Intriguing Obsession [fail] (diff=1800, combinatorics)
We can easily split the graph into 3 parts, these 3 parts are independent. For each part, we can firstly select K vertices for each color,
and then pair up the vertices. https://codeforces.com/contest/869/problem/C

106. Increasing Frequency [solved] (diff=2000, ad-hoc)
We definitely can only target 1 number. Let's say we want to increase the value v in range [l, r] to c. The cost of doing this is occ([l, r], v) - occ([l, r], c).
We want to maximize the cost. The idea is for each number v, we create a vector, which is for each position we put 1 and also the number of occurence 
of c between it and the next occurence of v. The problem is just reduced to the maximum subarray problem which is simple.
https://codeforces.com/contest/1082/problem/E

107. Three Paths on a Tree [solved] (diff=2000, greedy, ad-hoc)
We can observe that two points must be the endpoint of a diameter while the third point is the point that is furthest from this diameter.
https://codeforces.com/contest/1294/problem/F

108. Three Blocks Palindrome (hard version) [solved] (diff=1800, ad-hoc)
We can manipulate x for each number, and for y it is simply the maximum occurence number within a range. Note that since a[i] is up to 100, 
the maximum occurence number can be calculated using brute force, no need for Mo's algorithm or range tree. 
https://codeforces.com/contest/1335/problem/E2

109.  Interactive Treasure Hunt [solved] (diff=2200, ad-hoc)
Firstly, it's difficult to do this using binary search because the query is 7, less than O(logn * logm)
We can solve this problem using a set of linar equations.
ask on (1, 1): x1 - 1 + x2 - 1 + y1 - 1 + y2 - 1 = r1
x1 + x2 + y1 + y2 = r1 + 4 = c1
ask on (n, 1): n - x1 + n - x2 + y1 - 1 + y2 - 1 = r2
y1 + y2 - (x1 + x2) = r2 + 2 - 2 * n = c2
after 2 queries we know x1 + x2 and y1 + y2
x1 + x2 = (c1 - c2) / 2  --- (1)
y1 + y2 = (c1 + c2) / 2  --- (2)
we can ask at most 3 more queries before we guess the answer
now we guess ((x1 + x2) / 2, 1)
Then, y1 - 1 + y2 - 1 + (x1 + x2) / 2 - x1 + x2 - (x1 + x2) / 2 = r3 
x2 - x1 = r3 + 2 - (y1 + y2) = r3 + 2 - (c1 + c2) / 2 --- (3)
Hence, we can find x1 and x2 after this query
similarly, we can get y1 and y2
we query (1, (y1 + y2) / 2)
x1 - 1 + x2 - 1 + (y1 + y2) / 2 - y1 + y2 - (y1 + y2) / 2 = r4
Hence, (c1 - c2) / 2 + y2 - y1 = r4 + 2
It means y2 - y1 = r4 + 2 - (c1 - c2) / 2 -- (4)
However, at this point, we are not sure if it is (x1, y1) and (x2, y2) 
or it should be (x1, y2) or (x2, y1)
We just call dig (x1, y1) and see if it is there, it yes, then (x2, y2) is also correct -- (5, 6)
otherwise, we just dig (x1, y2) and (x2, y1)  -- (5, 6, 7)

110.  Connect the Points [solved] (diff=1800, ad-hoc)
https://codeforces.com/contest/1666/problem/C

111. Job Lookup [fail] (diff=2100, dp)
We can easily classify this problem as an interval dp. We define dp(l, r) as the minimum contribution of all the points in range (l, r) 
to the answer. Note that the difficult part is the distance between the points. We can However, deal with this issue in the following way.
Suppose we are calculating the answer (l, r) and there's a splitting point k. Then, apparently dp(l, r) = dp(l, k - 1) + dp(k + !, r) + something.
This "something" is actually the weight of the edge, we can set the edge as sum(c(i, j), i = l..r, j = {1..N} \ {l..r}).
https://codeforces.com/contest/1666/problem/J

112. The Hard Work of Paparazzi [solved] (diff=2000, dp)
This problem can be solved with brute force dp. Note that when we do transition, we don't need to consider all previous states, only 
states within t[i] - t[j] <= 2 * r. Because all other states can transite to the current state. https://codeforces.com/contest/1427/problem/C

113. The Number of Pairs [solved] (diff=2100, ad-hoc)
This is a very nice problem. 
Let gcd(a, b) = g
c * lcm(a,b) − d * gcd(a,b) = x
a * b * c / g - d * g = x
a * b * c = (x + d * g) * g
a * b = (x + d * g) * g / c --> c | (x + d * g) * g   (1) 
g * (a / g) * g * (b / g) = (x + d * g) * g / c
(a / g) * (b / g) = (x + d * g) / (g * c) --> (g * c) | (x + d * g) (2)
Let A = a / g, B = b / g, C = (x + d * g) / (g * c)
Thus, we want to calculate how many gcd(A, B) = 1 such that A * B = C
For each C, suppose it has K unique prime factors, then the number of pair A, B is simply 2 ^ K, we can use binary representation to 
understand why such calculation is correct.
For example,
c=2, d=7, x=25
g = 1, (x + d * g) / (g * c) = (25 + 7) / (1 * 2) = 16 --> 2
g = 5, (x + d * g) / (g * c) = (25 + 7 * 5) / (5 * 2) = 6 --> 4
g = 25, (x + d * g) / (g * c) = (25 + 7 * 25) / (25 * 2) = 4 --> 2

114. Odd-Even Subsequence [solved] (diff=2000, binary search, greedy)
For this kind of question our first idea is always binary search. Let the binary search term be: is it possible to find a subsequence of length
K such that the result of the calculation is no greater than V. To do the validation, we just greedily pick the numbers no greater than V,
with the constraint that these numbers must have gap 1. https://codeforces.com/contest/1370/problem/D  

115. Two Pizzas [solved] (diff=2100, bitmask, ad-hoc)
This problem is similar to https://codeforces.com/contest/1288/problem/D
We can find what's the minimum price for each mask and what are the two pizzas that can create this mask and price -- (1)
After that for each mask, suppose it to be the final answer, we want to count how many people with exactly this mask -- (2)
After that, we count for each mask, how many happy people, these are the pizzas with exactly this mask or a submask -- (3)
https://codeforces.com/contest/1185/problem/F

116. Playlist for Polycarp (hard version) [solved] (diff=2600, dp)
We can breakdown this problem into stages: firstly, for i type-1 items, j type-2 items and k type-3 items, each item is different, how many 
arrangements satisfy the adjacent item must be of different type. After this is solved, we can calculate how many ways of selecting songs 
such that there are i type-1 items, j type-2 items, and k type-3 items such that the total time is T. Note that both parts can be solved 
with knapsack dp. One remarks is how to do part 2, instead of design a state dp[i][j][k][T], we can seperate into 2 states 
dp[i][j][T] as the number of ways to use i type-1 item and j type-2 items with total time T, and dp2[i][T] as the number of ways to 
use i type-3 items with total time T. We can combine dp[i][j][T] and dp2[i][T] to calculate the answer for part 2.
https://codeforces.com/contest/1185/problem/G2

117. K-periodic Garland [solved] (diff=1900, ad-hoc)
Apparently, we can solve each starting point from 1 to K with a period of K seperately. 
For each of the sequence with period K.
Total cost = remove all 1 - save some 1 + change some 0 to 1
Total cost = remove all 1 - (save some 1 - change some 0 to 1)
Hence minimum cost = remove all 1 - maximum subarray after we change all 0 to -1.
https://codeforces.com/contest/1353/problem/E

118. GCD Counting [solved] (diff=2000, ad-hoc)
The idea is each number less than 2e5 has at most 6 unique prime factors. Then, we can manipulate each prime number between 2 and 2e5. 
This would grant each number can only be calculated 6 times. For each prime number, the graph is changed into a forest. And the answer for 
each prime number is the maximum diameter for each tree in the forest. Time complexity O(6 * N * log(N)), the log factor is from the binary search
that uses to determine if an edge present in the graph. https://codeforces.com/contest/1101/problem/D

119. Trucks and Cities [fail] (diff=2400, dp)
We should realize the value C_i actually doesn't matter. Because as long as we solve the problem for [s, f, c=1, r] the answer is simply 
the former answer times c_i. Now, we can use dp for this. Define dp[i][j][k] as  the minimum of the maximum gap when we have k refuels on
inverval [a[i], a[j]], dp[i][j][k] = min(max(dp[i][pos][k-1], a[j] - a[pos])) Note that the optimal pos is monotone.
Hence, we can use two pointers to find the optimal pos instead of always start from i. https://codeforces.com/contest/1101/problem/F

120. Zero Remainder Sum [solved] (diff=2100, dp)
We solve this problem in the following 2 stages:
(1) For each row, find the maximum number we can get by selecting no more than m / 2 numbers
such that the sum of these numbers mod j divided by K.
The target is to create an array of <mod, maximum sum> for each row
(2) after the array is created, we would solve the problem:
each row, we can select at most one pair
we want to calculate the maximum number we can achieve such that the sum of mod is divisable by K.
Both parts are solvable by knapsack dp.
https://codeforces.com/contest/1433/problem/F

121. Not Quite Lee [solved] (diff=2000, ad-hoc, combinatorics)
We can observe the following: each even number K controls K / 2 + p * K for a parameter p, each odd number controls p * K. 
There are 2 observations: 
(1) if the subsequence contains an odd number, we can always include it in the answer
(2) Let's say the subsequence only contains even numbers, and the even number has the minimum lowest bit occurs even number of time,
we can include it in the answer.
This transforms the problem into a simple combinatorics problem. https://codeforces.com/contest/1610/problem/D

122. Subsequences (easy & hard version) [solved] (diff=1900/2000, dp)
We can calculate how many distinct subsequences has length i for each i from 1 to N, and pick these sequences greedily from longer to shorter.
The dp definition is simple, dp[i][j] = number of subsequences end at i with length j.
The transition is simply dp[i][j] = sum(dp[lst[k]][j-1], k = a..z)
https://codeforces.com/contest/1183/problem/E

123. Topforces Strikes Back [solved] (diff=2100, greedy)
We first sort and unique the data. Then for each i, we iterate downward and find the first j (j < i) such that a[i] % a[j] != 0.
After we get this j, we iterate downward to find the first k < j such that a[i] % a[k] != 0 and a[j] % a[k] != 0.
Note that, the time complexity is correct, because the maximum iteration per number is at most 2 * D, here D is the maximum divisor 
a number can have, and an upper bound is sqrt(2e5). https://codeforces.com/contest/1183/problem/F

124 - 128 Codeforces Round #800 (Div. 2) A - E (a very sad practice :() 
https://codeforces.com/contest/1694

129. Gambling Guide [solved] (shortest path)
The idea is exactly the same as CF1694E, maybe I shouldn't escape from the problem in 2020.  dist[n] = 0
dist[x] = sum(min(dist[x], dist[y]) + 1) / deg[x]
Note that we cannot get this easily when we traverse the graph using dijkstra 
we rewrite the expression to:
dist[x] = sum(dist[y] + 1, such that dist[y] < dist[x]) / deg[x] + |{y | dist[y] >= dist[x]}| * (dist[x] + 1) / deg[x] 
        = 1 + sum(dist[y], such that dist[y] < dist[x]) / deg[x] + |{y | dist[y] >= dist[x]}| * dist[x] / deg[x]
Hence, dist[x] * (deg[x] - (|{y | dist[y] >= dist[x]}| / deg[x])) = (deg[x] + sum(dist[y], such that dist[y] < dist[x])) / deg[x]
dist[x] = (deg[x] + sum(dist[y], such that dist[y] < dist[x])) / |{y | dist[y] < dist[x]}|
The last term can be maintained using the same technique as the one used in CF1694E. 
https://codeforces.com/gym/101620/attachments/download/6377/20172018-acmicpc-central-europe-regional-contest-cerc-17-en.pdf

